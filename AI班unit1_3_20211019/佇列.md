電資二 10920137 柯文凱

# 佇列
原則:**First in First Out (FIFO) 先進先出**
佇列就像排隊一樣先進先出 ，後來的就只能在最後 **不能插隊 不能插隊 不能插隊!!!**
下圖就是一個用Circular Linked List 模擬佇列圖
![](https://i.imgur.com/a4ZL44K.gif)
>用循环队列模拟银行窗口排队 by weixin_39640008

可以看到頭的位置是不會隨便移動的，並且只能從頭進行獲取、移除的動作，尾部則是負責新增之後過來的資料

## 回文 Palindrome
利用佇列 **(先來先處理)** 跟堆疊 **(先處理現在來的)** 的特性 可以一次比對 一個字串前後尾巴
Ex. radar
程式碼:
```
    for (auto ch : text) {
        ch = std::toupper(ch);
        queue.push(ch);
        stack.push(ch);
    }
 
    // Determine if the string is a palindrome
    while (!queue.empty() && !stack.empty()) {
        if (queue.front() != stack.top()) {
            isPalindrome = false;
            break;
        }
        queue.pop();
        stack.pop();
    }
```
註記:在查詢相關資訊時發現了 rbegin() & rend() 都是STL裡面就有的功能，利用String就可以輕鬆辨別回文

# Big-O 表示法 Big O notation
*大O符號（英語：Big O notation），又稱為漸進符號，是用於描述函式漸近行為的數學符號。更確切地說，它是用另一個（通常更簡單的）函式來描述一個函式數量級的漸近上界。在數學中，它一般用來刻畫被截斷的無窮級數尤其是漸近級數的剩餘項；在電腦科學中，它在分析演算法複雜性的方面非常有用。* -取自維基百科[大O符號](https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7)

:bulb:用到的觀點 :
*  Time efficiency 時間效率
*  Space efficiency 空間效率

:question:為何要用Big-0 來比較? 
**目的是為了要比較出差距明顯的演算法** 下圖可以看到數據數量影響所花費的時間、各效率的線性圖表
![](https://i.imgur.com/AToCByV.png)
可以發現 其實剛開始可能時間差不多 **但隨著資料越來越多 影響到的時間差距越大**


主要的影響的因子:
* Specific implementation 實作細節---> ex.同樣的觀念，但有更有效率的程式碼
* Computer ---> ex.硬體設備、系統、最佳化
* Data ----> ex.資料的結構、排序方法 都適用於不同的演算法

常見的位階:
```
O(1) 常數階  O(log2n)對數階  O(n)線性階  O(nlog2n)線性對數階  
O(n²) 平方階 O(n³) 立方階 O(2^n)指數階
```

### 小結:
不得不說效率是真的很重要，在練習五時會有跑的特別久的數據。

## 演算法 Algorithms

### 氣泡排序 Bubble sort 
![](https://i.imgur.com/M4T2kyU.gif) ![](https://i.imgur.com/D8HFNQW.png)
>  由 原上傳者為英文維基百科的Nmnogueira - Own work by uploader using Matlab, CC BY-SA 

從第一個元素開始比較，如果達成條件就互換，直到第n個，再從下一項(第二項)繼續比較直到不須比較為止

目前學到的最輕鬆好記、觀念簡單的排序法，**萬金油的概念** 但是效率不高:laughing: 

範例:
```
function bubble_sort (array, length) {
    var i, j;
    for(i from 0 to length-1){
        for(j from 0 to length-1-i){
            if (array[j] > array[j+1])
                swap(array[j], array[j+1])
        }
    }
}
```

### 選擇排序 Selection Sort
![](https://i.imgur.com/fAZn8sp.gif) ![](https://i.imgur.com/lJgio21.png)

> 由 en:Marco Polo at en.wikipedia.org - 自己的作品 - originally uploaded at en.wikipedia.org

選擇排序法是一種**簡單直觀**的排序演算法先 從未排序的數字中挑出最小的數字，放入已排序的最尾端。(第一次以找到最小的數字)
第N次可以挑到所有數字中第N小的數字 (最大的數字)，最後就由小到大排完了

範例:
```
    for( i=0 ; i<N ; i=i+1 )
    {
        for( j=i+1 ; j<N ; j=j+1 )
        {
            if( num[i] > num[j] )
            {
                //變數交換
                tmp = num[i];
                num[i] = num[j];
                num[j] = tmp;
            }
        }
    }
```

### 希爾排序 Shell Sort
![](https://i.imgur.com/iPAXMxf.gif)![](https://i.imgur.com/WfYOxWY.png)
> 由 Simpsons contributor - 自己的作品, CC0

名稱的由來是以計者希爾（Donald Shell）的名字命名的 為插入排序法的改良
概念: 
間距(Gap) : n/2  <---最開始的概念
共n項元素，先以第一項跟1+(Gap)項比較，再以第二項跟(2+Gap)比較，以此類推到n項為止後，再以Gap/2重複以上動作 直到Gap為1為止。
**重要 :exclamation: Gap最後一定為1**

在後來的發展已知的最好步長序列是由Sedgewick提出的(1, 5, 19, 41, 109,...)，該序列的項 ![](https://i.imgur.com/nF3bRse.png)

範例:
```
void shell_sort(T array[], int length) {
    int h = 1;
    while (h < length / 3) {
        h = 3 * h + 1;
    }
    while (h >= 1) {
        for (int i = h; i < length; i++) {
            for (int j = i; j >= h && array[j] < array[j - h]; j -= h) {
                std::swap(array[j], array[j - h]);
            }
        }
        h = h / 3;
    }
}
```

### 合併排序 Merge Sort
![](https://i.imgur.com/CsLIGFs.gif)![](https://i.imgur.com/hPqYywp.png)
> 由 CobaltBlue - en.wikipedia, CC BY-SA 2.5, 
此演算法採用分治法（Divide and Conquer）
觀念
* 分割：遞迴地把當前序列平均分割成兩半。
* 整合：在保持元素順序的同時將上一步得到的子序列整合到一起（合併）。
* 白話文: **先分割到最小單位為止，一邊比較一邊合併!** <---比較適用於遞迴法的觀念

這邊只貼遞迴版本的 迭代版可以在[維基百科](https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)找到
程式:
```
void merge_sort_recursive(int arr[], int reg[], int start, int end) {
    if (start >= end)
        return;
    int len = end - start, mid = (len >> 1) + start;
    int start1 = start, end1 = mid;
    int start2 = mid + 1, end2 = end;
    merge_sort_recursive(arr, reg, start1, end1);
    merge_sort_recursive(arr, reg, start2, end2);
    int k = start;
    while (start1 <= end1 && start2 <= end2)
        reg[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];
    while (start1 <= end1)
        reg[k++] = arr[start1++];
    while (start2 <= end2)
        reg[k++] = arr[start2++];
    for (k = start; k <= end; k++)
        arr[k] = reg[k];
}

void merge_sort(int arr[], const int len) {
    int reg[len];
    merge_sort_recursive(arr, reg, 0, len - 1);
}
```
之前看介紹有說適合拿來做連接串列(Linked list)的整理， 另外小發現維基百科的複雜度用到Θ
[維基百科](https://zh.wikipedia.org/wiki/%E5%A4%A7%CE%98%E7%AC%A6%E5%8F%B7)介紹:![](https://i.imgur.com/VXO8Pck.png)

### 快速排序 Quick Sort 
![](https://i.imgur.com/dW1ZLZi.gif)![](https://i.imgur.com/pboFMJP.png)
> 由 en:User:RolandH, CC BY-SA 3.0, 

快速排序跟合併一樣使用分治法（Divide and conquer） 大多用運在陣列(Array)上會有較好的結果

大概的步驟分為:
* 挑選基準值：從數列中挑出一個元素，稱為「基準」（pivot），
* 分割：重新排序數列，所有比基準值小的元素擺放在基準前面，所有比基準值大的元素擺在基準後面（與基準值相等的數可以到任何一邊）。在這個分割結束之後，對基準值的排序就已經完成
* 遞迴排序子序列：遞迴地將小於基準值元素的子序列和大於基準值元素的子序列排序。

以下是維基百科提供的虛擬碼
Puesudo code :
```
 function quicksort(q)
 {
     var list less, pivotList, greater
     if length(q) ≤ 1 
         return q
     else 
     {
         select a pivot value pivot from q
         for each x in q except the pivot element
         {
             if x < pivot then add x to less
             if x ≥ pivot then add x to greater
         }
         add pivot to pivotList
         return concatenate(quicksort(less), pivotList, quicksort(greater))
     }
 }
```

### 基數排序 Radix Sort 
![](https://i.imgur.com/HnFxE2M.gif)![](https://i.imgur.com/TNJamwg.png)
>由 GnolizX - 自己的作品, CC BY-SA 4.0

gif調不了大小 :cry: 

基數排序是一種**非比較型**整數排序演算法 大概就是把各個數據的個位數先比較並排序，在往二 三位數比，直到最高位數排序完成，便會成為一個排列完成的數列。

Pusedo code present by codingeek.com : 
```
Radix-Sort(A, d)
//It works same as counting sort for d number of passes.
//Each key in A[1..n] is a d-digit integer.
//(Digits are numbered 1 to d from right to left.)
    for j = 1 to d do
        //A[]-- Initial Array to Sort
        int count[10] = {0};
        //Store the count of "keys" in count[]
        //key- it is number at digit place j
        for i = 0 to n do
         count[key of(A[i]) in pass j]++
        for k = 1 to 10 do
         count[k] = count[k] + count[k-1]
        //Build the resulting array by checking
        //new position of A[i] from count[k]
        for i = n-1 downto 0 do
         result[ count[key of(A[i])] ] = A[j]
         count[key of(A[i])]--
        //Now main array A[] contains sorted numbers
        //according to current digit place
        for i=0 to n do
          A[i] = result[i]
    end for(j)
end func
```

### 小結
最後介紹的基數排序真的非常的有趣，之前在比較的時候不會有這種想法，現在想想，挑戰題其實是可以打出來的，也許比Quick Sort for Linked List 還好打 。

# 二元樹 Binary Tree 
![](https://i.imgur.com/lcDjQcK.png)![](https://i.imgur.com/XNzq7Om.png)
> **由 Derrick Coetzee - 我個人以下列物件為基礎來創作： Binary tree.png, 公有領域,** 

二元樹顧名思義，就是每個節點最多只有兩個分支，且二元樹的分支具有左右次序，不能隨意顛倒。
觀念:
* 根(Root):最開始拿來比較來產生分支的數據
* 樹高(Depth) : 從根走到底的**最多步數** 通常樹高越小越好才不會影響效率
* 階層(Layers) : 以樹高判斷層數， **最大階層=樹高**

通常會有的功能:
* 建立新葉子
* 擷取
* 巡行
* 刪除
* 合併其他樹

通常葉子的結構:
```
 typedef struct CSNode
 {
   TElemType data; <--資料
   struct CSNode *firstchild,*nextsibling;  <----左右子孫
 }CSNode,*CSTree;
 ```

## 完全二元樹 Complete Binary tree
![](https://i.imgur.com/XNzq7Om.png) 這張照片即是一顆完整樹
完全二元樹是一個理想狀態，由於他的資料都儲存在同一階層所以 理想的效率較高。

## 二元搜尋樹 Binary Search Tree
![](https://i.imgur.com/k58KCq1.png)![](https://i.imgur.com/5KTWd9r.png)

即為一顆有依據特定觀念決定分支的樹
特點:
* 若任意節點的左子樹不空，則左子樹上所有節點的值均小於它的根節點的值
* 若任意節點的右子樹不空，則右子樹上所有節點的值均大於它的根節點的值
* 任意節點的左、右子樹也分別為二元搜尋樹

通常有的功能:
* 插入結點 Insert
* 刪除結點 Delete
* 巡行 Traverse 
* 尋找特定數據 Find smth

### 小結
其實不太確定二元樹這裡要打啥筆記，在大一的時候夏老大曾經有使用過，所以觀念還算可以，不加上程式碼的原因會變太過攏長，也可以在Wiki或Google就找的到，所以未加入。還有資料結構可能是我目前可以學到最多的課了 :thumbsup: 讚讚

